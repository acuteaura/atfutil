/*
 * Copyright 2023 Aurelia Schittler
 *
 * Licensed under the EUPL, Version 1.2 or – as soon they
   will be approved by the European Commission - subsequent
   versions of the EUPL (the "Licence");
 * You may not use this work except in compliance with the
   Licence.
 * You may obtain a copy of the Licence at:
 *
 * https://joinup.ec.europa.eu/software/page/eupl5
 *
 * Unless required by applicable law or agreed to in
   writing, software distributed under the Licence is
   distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
   express or implied.
 * See the Licence for the specific language governing
   permissions and limitations under the Licence.
*/

package render

import (
	"fmt"
	"io"

	"atfutil/pkg/atf"
	"atfutil/pkg/netcalc"
	"atfutil/pkg/netpool"
)

var (
	/* MarkerAlloc    = "ALLOC"
	MarkerFree     = "FREE"
	MarkerReserved = "RESERVED" */
	MarkerAlloc    = "✅"
	MarkerFree     = ""
	MarkerReserved = "⚠️"
)

func RenderPoolToMarkdown(target io.Writer, atfFile *atf.File, pool *netpool.IPNetPool, includeFree bool) {
	ipToAllocMap := make(map[string]atf.Allocation)

	for _, allocation := range atfFile.Allocations {
		ipToAllocMap[allocation.Network.String()] = allocation
		for _, subAlloc := range allocation.SubAlloc {
			ipToAllocMap[subAlloc.Network.String()] = subAlloc
		}
	}

	if atfFile.Name == nil {
		addedStr := " "
		if includeFree {
			addedStr += "(with empty blocks)"
		}
		fmt.Fprintf(target, "# %s%s\n\n", atfFile.Superblock.String(), addedStr)
	} else {
		addedStr := ""
		if includeFree {
			addedStr += ", with empty blocks"
		}
		fmt.Fprintf(target, "# %s (%s%s)\n\n", *atfFile.Name, atfFile.Superblock.String(), addedStr)
	}

	fmt.Fprintf(target, "[//]: # (%s)\n\n", "Generated by atfutil, DO NOT EDIT")

	dmr := NewDefaultAzureMarkdownRenderer(target)

	dmr.PrintHeader()

	for _, block := range pool.Pool.FindAllAllocations() {
		dmr.PrintAllocation(pool, block, ipToAllocMap, false, includeFree)
	}
}

type MarkdownRenderer interface {
	PrintHeader()
	PrintAllocation(pool *netpool.IPNetPool, block *netcalc.Block, ipMap map[string]atf.Allocation, isSub bool, includeFree bool)
}

type DefaultAzureMarkdownRenderer struct {
	target io.Writer
	fmtStr string
}

func (dmr *DefaultAzureMarkdownRenderer) PrintHeader() {
	fmt.Fprintf(dmr.target, dmr.fmtStr, "Alloc", "Ident", "Block", "SubAllocation", "Subscription", "Resource Group", "VNET", "Description")
	fmt.Fprintf(dmr.target, dmr.fmtStr, "-", "-", "-", "-", "-", "-", "-", "-")
}

func (dmr *DefaultAzureMarkdownRenderer) PrintAllocation(pool *netpool.IPNetPool, block *netcalc.Block, ipMap map[string]atf.Allocation, isSub bool, includeFree bool) {
	//isFree := true
	alloc := atf.Allocation{}
	status := MarkerFree

	if innerAlloc, ok := ipMap[block.Net.String()]; ok {
		//isFree = false
		status = MarkerAlloc
		alloc = innerAlloc
	}

	if alloc.IsReserved {
		status = MarkerReserved
	}

	var textBlock = block.Net.String()
	var textSubAlloc = ""

	if isSub {
		textSubAlloc = textBlock
		textBlock = ""
	}
	fmt.Fprintf(
		dmr.target,
		dmr.fmtStr,
		status,
		alloc.Ident,
		textBlock,
		textSubAlloc,
		alloc.Reference.Azure.Subscription,
		alloc.Reference.Azure.ResourceGroup,
		alloc.Reference.Azure.VirtualNetwork,
		alloc.Description,
	)

	if subAllocations, ok := pool.SubAllocations[block.Net.String()]; ok {
		for _, subBlock := range subAllocations.FindAllAllocations() {
			dmr.PrintAllocation(pool, subBlock, ipMap, true, includeFree)
		}
	}
}

func NewDefaultAzureMarkdownRenderer(target io.Writer) *DefaultAzureMarkdownRenderer {
	return &DefaultAzureMarkdownRenderer{
		fmtStr: "|%s|%s|%s|%s|%s|%s|%s|%s|\n",
		target: target,
	}
}
