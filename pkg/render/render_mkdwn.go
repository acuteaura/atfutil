/*
 * Copyright 2023 Aurelia Schittler
 *
 * Licensed under the EUPL, Version 1.2 or â€“ as soon they
   will be approved by the European Commission - subsequent
   versions of the EUPL (the "Licence");
 * You may not use this work except in compliance with the
   Licence.
 * You may obtain a copy of the Licence at:
 *
 * https://joinup.ec.europa.eu/software/page/eupl5
 *
 * Unless required by applicable law or agreed to in
   writing, software distributed under the Licence is
   distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
   express or implied.
 * See the Licence for the specific language governing
   permissions and limitations under the Licence.
*/

package render

import (
	"fmt"
	"io"

	"atfutil/pkg/atf"
	"atfutil/pkg/netpool"
)

func RenderPoolToMarkdown(target io.Writer, parsed *netpool.ParsedATF, includeFree bool) {
	ipToAllocMap := make(map[string]*atf.Allocation)

	for _, allocation := range parsed.File.Allocations {
		ipToAllocMap[allocation.Network.String()] = allocation
		for _, subAlloc := range allocation.SubAlloc {
			ipToAllocMap[subAlloc.Network.String()] = subAlloc
		}
	}

	if parsed.File.Name == nil {
		addedStr := " "
		if includeFree {
			addedStr += "(with empty blocks)"
		}
		fmt.Fprintf(target, "# %s%s\n\n", parsed.File.Superblock.String(), addedStr)
	} else {
		addedStr := ""
		if includeFree {
			addedStr += ", with empty blocks"
		}
		fmt.Fprintf(target, "# %s (%s%s)\n\n", *parsed.File.Name, parsed.File.Superblock.String(), addedStr)
	}

	fmt.Fprintf(target, "[//]: # (%s)\n\n", "Generated by atfutil, DO NOT EDIT")

	var dmr MarkdownRenderer = NewDefaultAzureMarkdownRenderer(target)

	dmr.PrintHeader()

	for _, block := range parsed.Pool.FindAllAllocations() {
		dmr.PrintAllocation(parsed, block.Net.String(), false, includeFree)
	}
}

type MarkdownRenderer interface {
	PrintHeader()
	PrintAllocation(parsed *netpool.ParsedATF, netstring string, isSub bool, includeFree bool)
}
